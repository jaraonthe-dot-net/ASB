/**
 * RISC-V commands
 */

/* Helper functions */
.define &calculate_address /register result''32, /variable imm''12(/register rs1''32) {
    &sign_extend result, imm
    &add result, result, rs1
}


/* LOAD/STORE */

// load byte
.define lb /register rd''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    .variable byte ''8
    &mov byte, @address
    &sign_extend rd, byte
}
// Load half
.define lh /register rd''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov rd'7:0, @address
    &add address, address, 1
    .variable byte ''8
    &mov byte, @address
    &sign_extend rd'31:8, byte
}
// Load word
.define lw /register rd''32, /immediate imm''12(/register rs1''32) {
    // TODO address should probably be divisible by for - check RISC-V docs &
    //      add assert if applicable. And what about lh?
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov rd'7:0, @address
    &add address, address, 1
    &mov rd'15:8, @address
    &add address, address, 1
    &mov rd'23:16, @address
    &add address, address, 1
    &mov rd'31:24, @address
}
// Load byte unsigned
.define lbu /register rd''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov rd, 0
    &mov rd'7:0, @address
}
// Load half unsigned
.define lhu /register rd''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov rd, 0
    &mov rd'7:0, @address
    &add address, address, 1
    &mov rd'15:8, @address
}
// Load upper immediate
.define lui /register rd''32, /immediate upimm''20 {
    &mov rd, 0
    &mov rd'31:12, upimm
}

// Store byte
.define sb /register rs2''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov @address, rs2'7:0
}
// Store half
.define sh /register rs2''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov @address, rs2'7:0
    &add address, address, 1
    &mov @address, rs2'15:8
}
// Store word
.define sw /register rs2''32, /immediate imm''12(/register rs1''32) {
    .variable address ''32; &calculate_address address, imm(rs1)
    
    &mov @address, rs2'7:0
    &add address, address, 1
    &mov @address, rs2'15:8
    &add address, address, 1
    &mov @address, rs2'23:16
    &add address, address, 1
    &mov @address, rs2'31:24
}


/* ARITHMETICAL */

// Add
.define add /register rd''32, /register rs1''32, /register rs2''32 {
    &add rd, rs1, rs2
}
// Add immediate
.define addi /register rd''32, /register rs1''32, /immediate imm''12 {
    .variable extended ''32; &sign_extend extended, imm
    &add rd, rs1, extended
}
// Sub
.define sub /register rd''32, /register rs1''32, /register rs2''32 {
    &sub rd, rs1, rs2
}


/* LOGICAL */

// And
.define and /register rd''32, /register rs1''32, /register rs2''32 {
    &and rd, rs1, rs2
}
// And immediate
.define andi /register rd''32, /register rs1''32, /immediate imm''12 {
    .variable extended ''32; &sign_extend extended, imm
    &and rd, rs1, extended
}

// Or
.define or /register rd''32, /register rs1''32, /register rs2''32 {
    &or rd, rs1, rs2
}
// Or immediate
.define ori /register rd''32, /register rs1''32, /immediate imm''12 {
    .variable extended ''32; &sign_extend extended, imm
    &or rd, rs1, extended
}

// Xor
.define xor /register rd''32, /register rs1''32, /register rs2''32 {
    &xor rd, rs1, rs2
}
// Xor immediate
.define xori /register rd''32, /register rs1''32, /immediate imm''12 {
    .variable extended ''32; &sign_extend extended, imm
    &xor rd, rs1, extended
}

// Helper
.define &sll /register rd''32, /register rs1''32, /register bits''5 {
    .variable rs1_start ''5; &sub rs1_start, 31, bits
    &mov rd'31:bits, rs1'rs1_start:0

    .variable bits_1 ''5; &add bits_1, bits, -1
    &mov rd'bits_1:0, 0
}
// Shift left logical
.define sll /register rd''32, /register rs1''32, /register rs2''32 {
    &sll rd, rs1, rs2'4:0
}
// Shift left logical immediate
.define slli /register rd''32, /register rs1''32, /immediate uimm''5 {
    &sll rd, rs1, uimm
}

// Helper
.define &srl /register rd''32, /register rs1''32, /register bits''5 {
    .variable rd_start ''5; &sub rd_start, 31, bits
    &mov rd'rd_start:0, rs1'31:bits

    .variable rd_start1 ''5; &add rd_start1, rd_start, 1
    &mov rd'31:rd_start1, 0
}
// Shift right logical
.define srl /register rd''32, /register rs1''32, /register rs2''32 {
    &srl rd, rs1, rs2'4:0
}
// Shift right logical immediate
.define srli /register rd''32, /register rs1''32, /immediate uimm''5 {
    &srl rd, rs1, uimm
}

// Helper
.define &sra /register rd''32, /register rs1''32, /register bits''5 {
    .variable rd_start ''5; &sub rd_start, 31, bits
    &mov rd'rd_start:0, rs1'31:bits

    // TODO do not execute if bits == 0 (as length cannot be 0)!
    .variable extension ''bits; &sign_extend extension, rd'rd_start

    .variable rd_start1 ''5; &add rd_start1, rd_start, 1
    &mov rd'31:rd_start1, extension
}
// Shift right arithmetic
.define sra /register rd''32, /register rs1''32, /register rs2''32 {
    &sra rd, rs1, rs2'4:0
}
// Shift right arithmetic immediate
.define srai /register rd''32, /register rs1''32, /immediate uimm''5 {
    &sra rd, rs1, uimm
}

// TODO: slti, sltiu, auipc, slt, sltu,
//       beq, bne, blt, bge, bltu, bgeu, jalr, jal
//       mul, mulh, mulhsu, mulhu, div, divu, rem, remu
