// TODO experimental file for development; it will be removed/revamped at some point

.include "../lib/risc-v/risc-v.asb"

addi ra, zero, 5
&println x1

add x5, x1, zero
&println t0
addi x5, x5, -25
&println t0

.define test_sign_extend {
    .variable test1 ''5;
    .variable test2 ''16;
    &mov test1, -12
    &sign_extend test2, test1
    
    &print test1; &print " => "; &println test2
    &print_s test1; &print " => "; &println_s test2
}
//test_sign_extend

.define test_sign_extend /immediate imm ''13 {
    .variable test1 '' 13;
    &mov test1, imm
    &print test1; &print " "; &print_x test1; &print " "; &println_b test1
}
test_sign_extend -3

&println "VIRTUAL REGISTER"
&print zero; addi zero, x0, 13; &print " => "; &println zero

&println "BITWISE ACCESS"
.define test_bitwise /immediate imm ''24 {
    &mov t0, 0xd
    &print_x t0
    
    &mov t0'19:8, imm'11:0
    &print " => "; &print_x t0
    
    &mov t0'15:8, t0'0:7
    &print " => "; &print_x t0
    
    &mov t0'15:8, t0'12:19
    &print " => "; &print_x t0
    
    &println
}
test_bitwise -22

&println "DYNAMIC LENGTH"
.define test_length /immediate len ''maxu500 {
    &normalize len
    &assert len <= 500
    
    .variable test ''len
    &mov test, -6
    &print test; &print ", "; &print_x test; &print ", "; &println_b test
    
    &sub len, len, 2
    &addc test, test'len:0, test'len:0
    &print "*2: "; &print test; &print ", "; &print_x test; &print ", "; &println_b test
}
test_length 23

&println "IMMEDIATE INDIRECTION"
.define test_immediate_indirection /immediate imm ''9 {
    &println imm
    &test_immediate_indirection imm
}
.define &test_immediate_indirection /variable var ''9 {
    &println var
}
test_immediate_indirection -9

&println "MEMORY"
.define test_memory /immediate imm ''8 {
    .variable tmp ''8
    .variable addr ''32
    
    &mov addr, 15; &print addr; &print ": "
    &mov tmp, @addr; &print_x tmp;
    &mov @addr, -42;
    &mov tmp, @addr; &print " => "; &println_x tmp
    &println @addr
    
    &mov addr, 12; &print addr; &print ": "
    &mov tmp, @addr; &print_x tmp;
    &mov @addr, imm
    &mov tmp, @addr; &print " => "; &println_x tmp
    &println_b @12
    &assert tmp == imm
}
test_memory 113
lw t0, 12(zero)
&println_x t0

&println "SYSTEM INFO"
.define test_system_info /immediate length ''maxu14 {
    .var tmp ''length
    
    &get_memory_word_length tmp;     &print "word length: ";              &print tmp
    &get_memory_address_length tmp;  &print "; address length: ";         &print tmp
    &get_program_counter_length tmp; &print "; program counter length: "; &println tmp
}
test_system_info 10

&println "LABELS & JUMPS"
my_label:
    &println "my_label:"
2ndLabel:
    &println "2ndLabel:"

.define test_jump {
start:
    &println "start:"
    &jump 5
skipped:
    &assert zero != zero, "this should have been skipped"
5:
    &println "5:"
    &jump .end
skipped2:
    &assert zero != zero, "this should have been skipped"
.end:
    &println ".end:"
}
test_jump

.define test_userland_jump /label label {
    &println_x label
    .variable v ''30; &add v, label, 5
    &println_x v
    &add label, label, 1
    &set_pc label
}
test_userland_jump nein

nein:
    &println "never say nein"

&println "Continue..."

&println "MUL, DIV, REM"
.define test_arithmetic /immediate factor ''16 {
    .variable a ''32; &mov a, 25
    .variable b ''16; &mov b, 8
    
    &print a; &print " * "; &print b; &print " = "
    &mul a, a'15:0, b
    &println a
    
    &print a; &print " / "; &print factor; &print " = "
    &div a'31:16, a'15:0, factor
    &rem a'15:0, a'15:0, factor
    &print a'31:16; &print " remainder "; &println a'15:0
}
test_arithmetic 12

&println "RESOLVING TIE-BREAKERS"
.define test_tie_breaker /immediate imm ''8 {
    &print "using smaller for imm "; &println imm
}
.define test_tie_breaker /immediate imm ''10 {
    &print "using bigger for imm "; &println imm
}
.define test_tie_breaker /register reg ''8 {
    &print "using smaller for reg ("; &print reg; &println ")"
}
.define test_tie_breaker /register reg ''10 {
    &print "using bigger for reg ("; &print reg; &println ")"
}
.define test_tie_breaker /label l {
    &print "using for label pointing to "; &println_x l
}
.define test_tie_breaker {
    .var _8  ''8;  &mov _8,  -7
    .var _10 ''10; &mov _10, 12
    test_tie_breaker _8
    test_tie_breaker _10
    test_tie_breaker nein
}
test_tie_breaker 1
test_tie_breaker 500
test_tie_breaker

&println "That's all folks"
